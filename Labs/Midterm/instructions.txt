________________________________________________________________________________		CS5004 Midterm -- Silicon Valley -- Prof Mark			Administered February 25, 2025________________________________________________________________________________			      MIDTERM EXAM RULES________________________________________________________________________________				       This is a proctored, in-person exam. You may use your laptop, the internet,Canvas, existing Piazza threads (but do not post during the exam!), materialsincluding slides from class, and your own notes. However, please do not copyand paste code from other sources that you have not written yourself, whetherfrom a website or a generative AI tool. It is fine to look things up such asthe name of a Java builtin class or the syntax for calling a particularmethod, to jog your memory. Accessing your own solutions to previousassignments is also fine.Please do not discuss the contents of this exam with anyone except theinstructor or the TAs before, during, or after taking the exam. One or twoclarification questions may be asked quietly. Please allow AT LEAST 10 MINUTESnear the end to commit and push your files to your GitHub repo, and upload theURL to Canvas, BEFORE the deadline. Late submissions will be severely penalized,since lateness provides an unfair advantage relative to other students.Modifying your code after the deadline is not OK, even if Canvas received yourURL on time. Both your pushed code and your Canvas-posted URL must be on time.________________________________________________________________________________				 INSTRUCTIONS________________________________________________________________________________This exam provides starter code. Please download the ".zip" file,uncompress it, and import the resulting folder hierarchy intoIntelliJ. (Keeping this ".txt" file in the folder is recommended.)There should be "src" and "test" folders as well. Use this command:		    File -> New Project From Existing SourcesYou may ask a TA or the instructor for help with this step, if needed. Somefiles are starter code requiring completion. You are working on parts of aMusic Playlist application. There are several tasks. One of the files,AbstractTune, deliberately contains bugs.WHAT TO DO:0. The following files must be understood, but you do NOT need to modify them:   Tune.java, Genre.java, Person.java, Mp3Tune.java, WavTune.java1. [20 points] Find FIVE bugs in AbstractTune.java. There may be more than five, but   you should report only five. Nearly identical bugs don't count. IntelliJ's yellow   warnings also do not count. Comment out buggy code. Add an extra line like this:   //BUG   to flag the bugs. Insert replacement code to fix the bugs. If you aren't sure or   lack time to fully correct a bug, add a comment describing the bug and your idea   for fixing it. Partial credit can be awarded even if you do not fully solve   the problem: finding a bug earns two points; fixing it earns up to four.2. [60 points] Implement the following unfinished code:    a. The compare method in TempoComparator.java    b. The compareTo method in AbstractTune.java    c. All unfinished methods in AbstractTune.java, including equals.    d. All unfinished Javadocs in AbstractTune.java    e. sortByTempo and sortByTitle in PlayList.java    f. Tests for those two sorting methods    g. All tests applicable to AbstractTune.java (except playTune)3. [20 points] Examine the three Class Diagrams provided, and answer the   following questions, by editing in your responses below after ">>>".       a. What is a good reason for a design such as  DiagramII, versus       the simpler version in DiagramI?    >>> DiagramII uses an AbstractShape class that lies between the Shape interface and the    concrete Circle and Rectangle classes. It is better than simpler version in DiagramI for    several reasons. Firstly, the abstract class includes methods like distToOrigin() and compareTo()    that are duplicated in Circle and Rectangles in the simpler version. Therefore, it avoids duplication.    Second, it creates a place to store the reference point used by all shapes. Last but not least,    the abstract class allows subclasses implement only the specific behaviors they need, such    as area() and perimeter() while inheriting common functions.        b. Try to infer what the "#" sign must mean in DiagramII. Why does this       matter?    >>> The "#" sign in DiagramII means "protected" access modifier. It means the reference field in    the AbstractShape is accessible to subclasses like Circle and Rectangle but not to external classes.    It is important because it encapsulates the internal representation while it enables subclasses to    access and use the reference point without exposing publicly. It is a good design for users to use    it while maintaining the data integrity.    c. Which links(s) in DiagramI should use a dark diamond arrowhead to       indicate a "has a" link?    >>> There are two links in DiagramI should use a dark diamond arrowhead to indicate a "has a" link.    1. The links from Circle to Point2D since the Circle "has-a" center Point2D as part of its composition.    2. The links from Rectangle to Point2D since the Rectangle "has-a" lowerLeft Point2D as part of its composition.        d. Which arrow in DiagramIII (x, y, or z) creates a "self-referential" structure?    >>> The arrow z creates a "self-referential" structure. The ElementNode class contains a field named    "rest: IList", meaning each ElementNode references another IList object.    This creates a recursive data structure where ElementNode references itself indirectly through the IList interface,    allowing multiple nodes to link together.